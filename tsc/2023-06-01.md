# OpenAssetIO TSC June 1st 2023

## Agenda

- Siggraph planning updates:
  - OpenRV secure EDL review
    - [MD] Now using OpenAssetIO to talk to official ML web services via Okta/Google for auth. Media being streamed throug storage service.
      - Okta bounce throug Google Auth via menu in OpenRV, produces a JWT - extracted into OpenRV along with target entity reference
      - OpenRV loads the OTIO file resolved from the returend ref
      - Media accessed via https and streamed.
      - RV is using ffmpeg, took a little juggling getting the headers right etc.
      - Next steps:
        - Token passed through the locale, will add PR for MediaCreation to add that trait
        - Need to look into OpenAssetIO API changes to properly handle login flow/reath (Meeting June 9th)
        - The natrative will evolve to include admin adding perms before access etc.
        - 1hr tokens
    - relatedReferences refactor done (awaiting merge/release)
  - Katana plugin prototype
- Result paging design update/discussion
  - [DF] About managing large numbers of results, looking at prior art in existing APIs/SDKs
    - Landed on a 'cursor object' that has methods to access data/navigate.
    - TBC is working out what the minimum set of API methods
      - Avoiding 'total results'
   - [EM] Some questions:
      - Is it feasible to ask for 'are there other pages'? Initial sketches highlighted challenges on the Manager side.
        - Try and see vs peremptive
        - [AM] For a UI, its really important to guide the user, so 'try and see' makes UI difficult.
          - Supports paging, but really needs a total count to be properly useful.
          - Making the determination of that value up to the host, if its needed or not vs always requiring it?
        - [EM] How important are performance guarantees?
           - [AM] Devs dont read docs - try and hope tricky, extra calls facilitate opt-in
       - [JR] When does paging happen?
          - [DF] The host is the one who knows that the need paging, etc
          - [AM/JR] Host should always define page size
            - Pagination not being numerical based
          - [OS] See GraphQL, edge count + has next etc... info for dev on pages available important
          - [AM] Allows users to jump to a numerical page.
        - [EM] Challenging as we have to support all potential back ends, lowest common demoninator? What about previous?
        - [JR] Are we aware that any back ends are more favourable and so could be tailored to.
        - [DM] Warned off total pages, see goggle et al
        - [EM] Also keen to ensure minimum number of optional methods
          - [OS] Total count is only really useful for a user - especially as it's an unstable quantity in a real-world system.
            - [AM] What assumptions are baked in? eg: many dont' support stability.
        - [DM] (for those who know back ends) how common knowing 'has more' etc... after a results request.
           - [AM] Elasticsearch and others match the next page token etc... so it's common.
        - [EM] How can we ensure we define the performance implications of calls that rely on data from other methods internally.
          - [AM] Simple discoverable API important, query delays are relative too.
          - [OS] If you are getting back overwealming data that means that counting is too heavy indicates another problem - better to ensure it is usable.
          - [EM] As a dev how had is it to handle variable latency in queries when building a UI?
            - [AM] Ensure ther are documented guidelines around what is slow/fast, and even then upper limits etc...? Goals
          - [JR] All API calls should be async
            - [AM] If its async then the query is too heavy? but ballance with inherent latency considerations etc. 
            - [JR] Importance of ensuring that the API has means to manage cost when it is prohibitive
            - [AM] What is the actual purposes of this paging?
              - [DF] Versions/relations that are all to-many with cited cases of large data sizes that may not be needed by the host.
           - [AM] (I) look throug through the build 80% and fix 20 later, which camp is this in? Woudln't put async on it unless there is a specific reason.
             - [JR] Depends on who you are trying to make easier, low level dev or UX dev?
             - [AM] Can see that calls could be long-running for lots of records, but doesn't neccesarily help as time to first byte, vs transmission as transmission cost is the same.
               - [MD] TTFB can be huge for some of these queries.
               - [JR] async is mainly about UI responsiveness.
               - [AM] In that case should all API methods be ASYNC?
                 - [MDv] Ideally! But practically simple is first best to aid adoption!
                 - [AM] We need to make sure these philosphies are written down!
                   - [DF] Can we bolt on async (around blocking)
                     - [AM] Yeah, for sure, but does it help ensure philosphy
                      - Is there a design pattern that can toggle async?
                        - [DF] Not in C++
           - [OS] From the PoV of a back-end, already have existing end points that cover a lot of this do we need this in the lower level API?
           - [MDw] Some mechnism that is more notional vs aboslute can be a good compromise - eg: are there more results vs how many
             - [AM] RWS: Customer updating a record once per second and had a hunderd millions of revisions - was an accident, but shows that systems need to deal with these extreme scenarios if they are even a remote possibility, assmue worst case.
   - JS/C# still mainstay for UI, Python for in-DCC work
   - [AM] ...async
     - External API connctions are allways async, but handled in a thread wrapper vs the API itself to ensure client threads are released? Should it be done through forcing an async API or a client side thread switch?
     - [MDv] General rule is that no matter how bad you think it is, its always worse. Try and avoid triggering worst case
       - counts hard, answering correctly can be hard esp in distributed scenarios.
   - [AM] This is a hard problem! It's not easy - how do you even begin due to the variety of scenarios.
   - [DF] Ok with: Simplicity preferred, OK to be able to say 'more pages available'
     - [AM] If the 80% dont like i, people will do it other wise, take everything shake it up and worry about the 80% as a key target to force adoption. It will take sacrifices. Take the hard choices that make the majority happier.
     - [MD] Votes for whatever gets DCC first.
     - [AM] Who is the primary target for the API
       - [TC] Feels like DCCs have to make a start
       - [OS] Pipelines that have to use custom APIs as the want their own workflows. They're the ones that need convincing to use it
         - [EM] About helping enable better pipielines.
